//
// SubscriptionPlan.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct SubscriptionPlan: Codable, JSONEncodable, Hashable {

    public enum ModelType: String, Codable, CaseIterable {
        case basic = "BASIC"
        case standard = "STANDARD"
    }
    public enum Currency: String, Codable, CaseIterable {
        case krw = "KRW"
        case usd = "USD"
        case vnd = "VND"
    }
    public enum RecentTransactionStatus: String, Codable, CaseIterable {
        case _none = "NONE"
        case requested = "REQUESTED"
        case resultWaiting = "RESULT_WAITING"
        case succeeded = "SUCCEEDED"
        case retryRequired = "RETRY_REQUIRED"
        case finallyFailed = "FINALLY_FAILED"
    }
    public var nextScheduledType: SubscriptionPlanType?
    public var id: String
    public var storeId: String
    public var type: ModelType
    public var currency: Currency
    public var amount: Double
    public var scheduledServiceEndDate: Date?
    public var nextSchedulePaymentDate: Date?
    public var recentPaymentDate: Date?
    public var recentTransactionRetriedCount: Double
    public var recentTransactionId: String?
    public var recentTransactionStatus: RecentTransactionStatus
    public var createdAt: Date
    public var updatedAt: Date
    public var deletedAt: Date?

    public init(nextScheduledType: SubscriptionPlanType? = nil, id: String, storeId: String, type: ModelType, currency: Currency, amount: Double, scheduledServiceEndDate: Date?, nextSchedulePaymentDate: Date?, recentPaymentDate: Date?, recentTransactionRetriedCount: Double, recentTransactionId: String?, recentTransactionStatus: RecentTransactionStatus, createdAt: Date, updatedAt: Date, deletedAt: Date?) {
        self.nextScheduledType = nextScheduledType
        self.id = id
        self.storeId = storeId
        self.type = type
        self.currency = currency
        self.amount = amount
        self.scheduledServiceEndDate = scheduledServiceEndDate
        self.nextSchedulePaymentDate = nextSchedulePaymentDate
        self.recentPaymentDate = recentPaymentDate
        self.recentTransactionRetriedCount = recentTransactionRetriedCount
        self.recentTransactionId = recentTransactionId
        self.recentTransactionStatus = recentTransactionStatus
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.deletedAt = deletedAt
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case nextScheduledType
        case id
        case storeId
        case type
        case currency
        case amount
        case scheduledServiceEndDate
        case nextSchedulePaymentDate
        case recentPaymentDate
        case recentTransactionRetriedCount
        case recentTransactionId
        case recentTransactionStatus
        case createdAt
        case updatedAt
        case deletedAt
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(nextScheduledType, forKey: .nextScheduledType)
        try container.encode(id, forKey: .id)
        try container.encode(storeId, forKey: .storeId)
        try container.encode(type, forKey: .type)
        try container.encode(currency, forKey: .currency)
        try container.encode(amount, forKey: .amount)
        try container.encode(scheduledServiceEndDate, forKey: .scheduledServiceEndDate)
        try container.encode(nextSchedulePaymentDate, forKey: .nextSchedulePaymentDate)
        try container.encode(recentPaymentDate, forKey: .recentPaymentDate)
        try container.encode(recentTransactionRetriedCount, forKey: .recentTransactionRetriedCount)
        try container.encode(recentTransactionId, forKey: .recentTransactionId)
        try container.encode(recentTransactionStatus, forKey: .recentTransactionStatus)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encode(updatedAt, forKey: .updatedAt)
        try container.encode(deletedAt, forKey: .deletedAt)
    }
}

