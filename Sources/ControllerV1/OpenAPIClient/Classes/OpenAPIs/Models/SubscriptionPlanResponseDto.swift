//
// SubscriptionPlanResponseDto.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct SubscriptionPlanResponseDto: Codable, JSONEncodable, Hashable {

    public enum ModelType: String, Codable, CaseIterable {
        case basic = "BASIC"
        case standard = "STANDARD"
    }
    public enum Currency: String, Codable, CaseIterable {
        case krw = "KRW"
        case usd = "USD"
        case vnd = "VND"
    }
    public enum RecentTransactionStatus: String, Codable, CaseIterable {
        case _none = "NONE"
        case requested = "REQUESTED"
        case resultWaiting = "RESULT_WAITING"
        case succeeded = "SUCCEEDED"
        case retryRequired = "RETRY_REQUIRED"
        case finallyFailed = "FINALLY_FAILED"
    }
    public var nextScheduledType: SubscriptionPlanType?
    public var id: String
    public var storeId: String
    public var type: ModelType
    public var currency: Currency
    public var amount: Double
    public var scheduledServiceEndDate: Date?
    public var nextSchedulePaymentDate: Date?
    public var recentPaymentDate: Date?
    public var recentTransactionRetriedCount: Double
    public var recentTransactionId: String?
    public var recentTransactionStatus: RecentTransactionStatus
    public var createdAt: Date
    public var updatedAt: Date
    public var deletedAt: Date?
    public var recentTransaction: Transaction?

    public init(nextScheduledType: SubscriptionPlanType? = nil, id: String, storeId: String, type: ModelType, currency: Currency, amount: Double, scheduledServiceEndDate: Date?, nextSchedulePaymentDate: Date?, recentPaymentDate: Date?, recentTransactionRetriedCount: Double, recentTransactionId: String?, recentTransactionStatus: RecentTransactionStatus, createdAt: Date, updatedAt: Date, deletedAt: Date?, recentTransaction: Transaction? = nil) {
        self.nextScheduledType = nextScheduledType
        self.id = id
        self.storeId = storeId
        self.type = type
        self.currency = currency
        self.amount = amount
        self.scheduledServiceEndDate = scheduledServiceEndDate
        self.nextSchedulePaymentDate = nextSchedulePaymentDate
        self.recentPaymentDate = recentPaymentDate
        self.recentTransactionRetriedCount = recentTransactionRetriedCount
        self.recentTransactionId = recentTransactionId
        self.recentTransactionStatus = recentTransactionStatus
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.deletedAt = deletedAt
        self.recentTransaction = recentTransaction
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case nextScheduledType
        case id
        case storeId
        case type
        case currency
        case amount
        case scheduledServiceEndDate
        case nextSchedulePaymentDate
        case recentPaymentDate
        case recentTransactionRetriedCount
        case recentTransactionId
        case recentTransactionStatus
        case createdAt
        case updatedAt
        case deletedAt
        case recentTransaction
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(nextScheduledType, forKey: .nextScheduledType)
        try container.encode(id, forKey: .id)
        try container.encode(storeId, forKey: .storeId)
        try container.encode(type, forKey: .type)
        try container.encode(currency, forKey: .currency)
        try container.encode(amount, forKey: .amount)
        try container.encode(scheduledServiceEndDate, forKey: .scheduledServiceEndDate)
        try container.encode(nextSchedulePaymentDate, forKey: .nextSchedulePaymentDate)
        try container.encode(recentPaymentDate, forKey: .recentPaymentDate)
        try container.encode(recentTransactionRetriedCount, forKey: .recentTransactionRetriedCount)
        try container.encode(recentTransactionId, forKey: .recentTransactionId)
        try container.encode(recentTransactionStatus, forKey: .recentTransactionStatus)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encode(updatedAt, forKey: .updatedAt)
        try container.encode(deletedAt, forKey: .deletedAt)
        try container.encodeIfPresent(recentTransaction, forKey: .recentTransaction)
    }
}

